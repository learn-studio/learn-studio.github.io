<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>關於作者 | Betty C.</title>

    <link rel="icon" type="image/png" href="https://learn-kits.github.io/image/learnkits_favicon.png">
    
    <!-- 引入字體 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=Noto+Sans+TC:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <style>
        /* --- 變數設定 --- */
        :root {
            --bg-body: #F8FAFC;
            --bg-card: #FFFFFF;
            --text-main: #1E293B;
            --text-sub: #64748B;
            --primary-gradient: linear-gradient(135deg, #4F46E5 0%, #7C3AED 100%);
            --shadow-card: 0 20px 60px -10px rgba(71, 85, 105, 0.15);
        }

        body {
            font-family: 'Outfit', 'Noto Sans TC', sans-serif;
            margin: 0; padding: 0;
            background-color: var(--bg-body);
            
            /* ★ 修改重點 1：使用 dvh 解決手機網址列遮擋問題 */
            height: 100vh;
            height: 100dvh; 
            
            width: 100vw;
            overflow: hidden;
            position: relative;
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }

        /* --- 1. 背景呼吸光點層 --- */
        .ambient-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
            overflow: hidden;
        }

        .light-blob {
            position: absolute;
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0.6;
            animation: breathe 10s infinite ease-in-out alternate;
        }

        .blob-1 { top: -10%; left: -10%; width: 50vw; height: 50vw; background: #E0E7FF; animation-duration: 15s; }
        .blob-2 { bottom: -10%; right: -10%; width: 60vw; height: 60vw; background: #F3E8FF; animation-duration: 12s; animation-delay: -5s; }
        .blob-3 { top: 40%; left: 40%; width: 30vw; height: 30vw; background: #EFF6FF; opacity: 0.5; animation: floatMove 20s infinite ease-in-out; }

        @keyframes breathe { 0% { transform: scale(1); } 100% { transform: scale(1.1); } }
        @keyframes floatMove {
            0% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(100px, -50px) rotate(120deg); }
            66% { transform: translate(-50px, 100px) rotate(240deg); }
            100% { transform: translate(0, 0) rotate(360deg); }
        }

        /* --- 2. 俄羅斯方塊畫布層 --- */
        #tetrisCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 50%; 
            height: 100%;
            z-index: 1;
            opacity: 0.9;
        }

        /* --- 3. 右下角資訊卡片 --- */
        .info-card {
            position: absolute;
            bottom: 64px; 
            right: 64px;
            width: 380px;
            background-color: var(--bg-card);
            border-radius: 24px;
            box-shadow: var(--shadow-card);
            padding: 32px;
            box-sizing: border-box;
            z-index: 10;
            
            opacity: 0;
            transform: translateY(30px);
            animation: floatIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            animation-delay: 0.3s;
            pointer-events: auto;
        }

        @keyframes floatIn { to { opacity: 1; transform: translateY(0); } }

        /* --- 卡片內容 --- */
        .card-header { margin-bottom: 16px; }
        .name-title { font-size: 1.8em; font-weight: 700; color: var(--text-main); margin: 0; line-height: 1.2; letter-spacing: -0.5px; }
        .job-title { font-size: 0.9em; color: var(--text-sub); font-weight: 500; text-transform: uppercase; letter-spacing: 1px; margin-top: 4px; }
        .card-content p { color: var(--text-sub); font-size: 15px; line-height: 1.6; font-weight: 400; margin: 0 0 24px 0; text-align: left; }

        .footer-action { 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
        }
        
        .contact-btn {
            background: var(--primary-gradient); color: white; padding: 10px 20px; border-radius: 12px;
            text-decoration: none; font-size: 14px; font-weight: 600; display: inline-flex;
            align-items: center; gap: 8px; cursor: pointer; transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
        }
        .contact-btn:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(79, 70, 229, 0.4); }
        .contact-btn .material-icons { font-size: 18px; }
        .copy-hint { color: #10B981; font-size: 12px; font-weight: 500; opacity: 0; transition: 0.3s; }
        .copy-hint.show { opacity: 1; }

        /* --- ★ RWD 手機版設定 ★ --- */
        @media (max-width: 768px) {
            .info-card { 
                /* ★ 修改重點 2：調整底部距離，確保不被網址列吃掉 */
                bottom: 25px; 
                right: 20px; 
                left: 20px; 
                width: auto; 
                padding: 24px; 
            }

            .name-title { font-size: 18px; }
            .job-title { font-size: 12px; margin-top: 2px; }
            .card-content p { font-size: 13px; line-height: 1.6; margin-bottom: 20px; }
            .contact-btn { font-size: 13px; padding: 8px 16px; }
            .contact-btn .material-icons { font-size: 16px; }
            
            #tetrisCanvas { 
                width: 100%;
                /* ★ 修改處：移除原本寫死的 height，改為 auto 或 100% 讓 JS 控制 */
                height: 100%;
            }
        }
    </style>
</head>
<body>

    <div id="header-container"></div>
    
    <div class="ambient-layer">
        <div class="light-blob blob-1"></div>
        <div class="light-blob blob-2"></div>
        <div class="light-blob blob-3"></div>
    </div>

    <canvas id="tetrisCanvas"></canvas>

    <div class="info-card">
        <div class="card-header">
            <h1 class="name-title">Betty C.</h1>
            <div class="job-title">Product Designer</div>
        </div>
        <div class="card-content">
            <p>
                在邏輯與創意之間尋找平衡。<br>
                專注於使用者體驗與介面設計，享受從混亂中梳理出秩序的過程。
            </p>
        </div>
        <div class="footer-action">
            <div class="contact-btn" onclick="copyEmail()">
                <span class="material-icons">mail</span>
                bochen722@gmail.com
            </div>
            <span class="copy-hint" id="copy-hint">Copied!</span>
        </div>
    </div>

    <script>
        function copyEmail() {
            navigator.clipboard.writeText("bochen722@gmail.com").then(() => {
                const hint = document.getElementById('copy-hint');
                hint.classList.add('show');
                setTimeout(() => hint.classList.remove('show'), 2000);
            });
        }

        fetch('header.html')
            .then(r => r.ok ? r.text() : Promise.reject())
            .then(d => {
                document.getElementById('header-container').innerHTML = d;
                window.toggleMobileMenu = () => document.getElementById('mobileNav')?.classList.toggle('open');
            })
            .catch(() => console.log('Header load skipped'));

        /* --- 俄羅斯方塊遊戲邏輯 --- */
        const canvas = document.getElementById('tetrisCanvas');
        const ctx = canvas.getContext('2d');
        
        // ★ 修改重點 4：手機版方塊大小改為 18px (原本35px，約縮小50%)
        const BLOCK_SIZE = window.innerWidth < 768 ? 18 : 30;
        
        const COLORS = [
            null,
            '#4F46E5', '#6366F1', '#818CF8', '#A78BFA', '#C084FC', '#94A3B8', '#64748B'
        ];

        const PIECES = 'ILJOTSZ';
        const SHAPES = {
            'I': [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
            'L': [[0,0,2],[2,2,2],[0,0,0]],
            'J': [[3,0,0],[3,3,3],[0,0,0]],
            'O': [[4,4],[4,4]],
            'Z': [[5,5,0],[0,5,5],[0,0,0]],
            'S': [[0,6,6],[6,6,0],[0,0,0]],
            'T': [[0,7,0],[7,7,7],[0,0,0]]
        };

        let board = [];
        let cols = 0;
        let rows = 0;
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        let player = { pos: {x: 0, y: 0}, matrix: null, color: 0 };

        function resize() {
            // 1. 先重置高度，確保讀取數值正確
            canvas.style.height = '100%'; 

            // 2. 手機版專屬計算：動態決定地板高度
            if (window.innerWidth < 768) {
                const card = document.querySelector('.info-card');
                if (card) {
                    // 取得卡片距離視窗頂部的位置 (Card Top)
                    const cardTop = card.getBoundingClientRect().top;
                    
                    // 設定畫布高度 = 卡片頂部位置 - 24px (留白)
                    // 這樣地板線就會剛好畫在卡片上方 24px 處
                    const targetHeight = cardTop - 24;
                    
                    canvas.style.height = targetHeight + 'px';
                }
            }

            // 3. 設定 Canvas 解析度 (這部分維持原樣)
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // 4. 計算網格 (維持原樣)
            cols = Math.floor(canvas.width / BLOCK_SIZE);
            rows = Math.floor(canvas.height / BLOCK_SIZE);
            
            // 重建遊戲盤面
            createBoard();
        }

        function createBoard() {
            board = Array.from({length: rows}, () => Array(cols).fill(0));
        }

        function createPiece(type) {
            const matrix = SHAPES[type];
            const colorIndex = (PIECES.indexOf(type) % (COLORS.length - 1)) + 1;
            return matrix.map(row => row.map(val => val ? colorIndex : 0));
        }

        function drawMatrix(matrix, offset) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = COLORS[value];
                        ctx.fillRect((x + offset.x) * BLOCK_SIZE + 1, (y + offset.y) * BLOCK_SIZE + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
                        ctx.fillStyle = 'rgba(255,255,255,0.2)';
                        ctx.fillRect((x + offset.x) * BLOCK_SIZE + 1, (y + offset.y) * BLOCK_SIZE + 1, BLOCK_SIZE - 2, 4);
                    }
                });
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 畫手機版的地板線
            if (window.innerWidth < 768) {
                const floorY = rows * BLOCK_SIZE;
                ctx.beginPath();
                ctx.moveTo(0, floorY);
                ctx.lineTo(canvas.width, floorY);
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgba(79, 70, 229, 0.1)';
                ctx.stroke();
            }

            drawMatrix(board, {x: 0, y: 0});
            drawMatrix(player.matrix, player.pos);
        }

        function merge(board, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        if(board[y + player.pos.y] && board[y + player.pos.y][x + player.pos.x] !== undefined) {
                            board[y + player.pos.y][x + player.pos.x] = value;
                        }
                    }
                });
            });
        }

        function collide(board, player) {
            const m = player.matrix;
            const o = player.pos;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 &&
                       (board[y + o.y] && board[y + o.y][x + o.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        function arenaSweep() {
            outer: for (let y = board.length - 1; y > 0; --y) {
                for (let x = 0; x < board[y].length; ++x) {
                    if (board[y][x] === 0) {
                        continue outer;
                    }
                }
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row);
                ++y;
            }
        }

        function rotate(matrix, dir) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            if (dir > 0) matrix.forEach(row => row.reverse());
            else matrix.reverse();
        }

        function playerReset() {
            const pieces = PIECES;
            player.matrix = createPiece(pieces[pieces.length * Math.random() | 0]);
            player.pos.y = 0;
            player.pos.x = (cols / 2 | 0) - (player.matrix[0].length / 2 | 0);

            if (collide(board, player)) {
                board.forEach(row => row.fill(0));
            }
        }

        function playerDrop() {
            player.pos.y++;
            if (collide(board, player)) {
                player.pos.y--;
                merge(board, player);
                arenaSweep();
                playerReset();
            }
            dropCounter = 0;
        }

        function playerMove(dir) {
            player.pos.x += dir;
            if (collide(board, player)) {
                player.pos.x -= dir;
            }
        }

        function playerRotate(dir) {
            const pos = player.pos.x;
            let offset = 1;
            rotate(player.matrix, dir);
            while (collide(board, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) {
                    rotate(player.matrix, -dir);
                    player.pos.x = pos;
                    return;
                }
            }
        }

        function update(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                playerDrop();
            }
            draw();
            requestAnimationFrame(update);
        }

        document.addEventListener('keydown', event => {
            if (event.keyCode === 37) playerMove(-1);
            else if (event.keyCode === 39) playerMove(1);
            else if (event.keyCode === 40) playerDrop();
            else if (event.keyCode === 38) playerRotate(1);
        });

// --- 2. 手機觸控控制 (優化版：支援即時拖曳下滑) ---
        let touchStartX = 0;
        let touchStartY = 0;
        let isSwiping = false; // 用來判斷是否正在滑動

        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            isSwiping = false; // 重置滑動狀態
        }, {passive: false});

        canvas.addEventListener('touchmove', e => {
            e.preventDefault(); // 防止畫面捲動
            
            if (!player.matrix) return; // 避免未初始化錯誤

            const touchCurrentX = e.touches[0].clientX;
            const touchCurrentY = e.touches[0].clientY;
            
            const diffY = touchCurrentY - touchStartY;
            const diffX = touchCurrentX - touchStartX;

            // ★ 下滑邏輯優化：
            // 只要垂直移動超過 30px，且垂直幅度大於水平幅度，就觸發「落下」
            // 並且重置 startY，這樣手指繼續往下拖，就會連續加速落下
            if (diffY > 30 && Math.abs(diffY) > Math.abs(diffX)) {
                playerDrop();
                touchStartY = touchCurrentY; // 重置起點，實現連續拖曳
                isSwiping = true; // 標記為正在滑動，避免手指放開時誤觸點擊
            }
        }, {passive: false});

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            
            // 如果剛剛發生過「滑動(下滑加速)」，手指放開時就什麼都不做
            if (isSwiping) return;

            // --- 點擊 (Tap) 邏輯 ---
            // 如果沒有滑動，才執行左右移動或旋轉
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;

            // 為了避免誤觸，點擊判斷稍微嚴格一點 (位移小於 10px 才算點擊)
            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;

            if (Math.abs(diffX) < 10 && Math.abs(diffY) < 10) {
                // 點擊上半部 (40%區域)：旋轉
                if (touchEndY < screenHeight * 0.4) {
                    playerRotate(1);
                } 
                // 點擊左半部：左移
                else if (touchEndX < screenWidth / 2) {
                    playerMove(-1);
                } 
                // 點擊右半部：右移
                else {
                    playerMove(1);
                }
            }
        }, {passive: false});

        window.addEventListener('resize', resize);
        resize();
        playerReset();
        update();

    </script>
</body>
</html>
